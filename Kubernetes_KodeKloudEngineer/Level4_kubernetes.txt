Question 1: The Nautilus application development team observed some performance issues with one of the application that is deployed in Kubernetes cluster. After looking into number of factors, the team has suggested to use some in-memory caching utility for DB service. After number of discussions, they have decided to use Redis. Initially they would like to deploy Redis on kubernetes cluster for testing and later they will move it to production. Please find below more details about the task:

Create a redis deployment with following parameters:
Create a config map called my-redis-config having maxmemory 2mb in redis-config.
Name of the deployment should be redis-deployment, it should use
redis:alpine image and container name should be redis-container. Also make sure it has only 1 replica.
The container should request for 1 CPU.
Mount 2 volumes:
a. An Empty directory volume called data at path /redis-master-data.
b. A configmap volume called redis-config at path /redis-master.
c. The container should expose the port 6379.
Finally, redis-deployment should be in an up and running state.

Solutions:
Create the configmap -> kubectl create configmap my-redis-config --from-literal=maxmemory=2mb
Create the yaml and apply
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      db: redis
  template:
    metadata:
      labels:
        db: redis
    spec:
      containers:
        - name: redis-container
          image: redis:alpine
          resources:
            requests:
              cpu: "1"
          ports:
           - containerPort: 6379
          volumeMounts:
             - name: data
               mountPath: /redis-master-data
             - name: redis-config
               mountPath: /redis-master
      volumes:
        - name: data
          emptyDir: {}
        - name: redis-config
          configMap:
            name: my-redis-config
check all the resource are up and running

Question 2: A new MySQL server needs to be deployed on Kubernetes cluster. The Nautilus DevOps team was working on to gather the requirements. Recently they were able to finalize the requirements and shared them with the team members to start working on it. Below you can find the details:

1.) Create a PersistentVolume mysql-pv, its capacity should be 250Mi, set other parameters as per your preference.
2.) Create a PersistentVolumeClaim to request this PersistentVolume storage. Name it as mysql-pv-claim and request a 250Mi of storage. Set other parameters as per your preference.
3.) Create a deployment named mysql-deployment, use any mysql image as per your preference. Mount the PersistentVolume at mount path /var/lib/mysql.
4.) Create a NodePort type service named mysql and set nodePort to 30007.
5.) Create a secret named mysql-root-pass having a key pair value, where key is password and its value is YUIidhb667, create another secret named mysql-user-pass having some key pair values, where frist key is username and its value is kodekloud_pop, second key is password and value is ksH85UJjhb, create one more secret named mysql-db-url, key name is database and value is kodekloud_db6
6.) Define some Environment variables within the container:
a) name: MYSQL_ROOT_PASSWORD, should pick value from secretKeyRef name: mysql-root-pass and key: password
b) name: MYSQL_DATABASE, should pick value from secretKeyRef name: mysql-db-url and key: database
c) name: MYSQL_USER, should pick value from secretKeyRef name: mysql-user-pass key key: username
d) name: MYSQL_PASSWORD, should pick value from secretKeyRef name: mysql-user-pass and key: password

Solution:
Create the PV
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
  labels:
    type: local
spec:
  storageClassName: manual
  capacity:
    storage: 250Mi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data/mysql"

Create the PVC
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 250Mi

Create the deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
  labels:
    db: mysql
spec:
  replicas: 2
  selector:
    matchLabels:
      db: mysql
  template:
    metadata:
      labels:
        db: mysql
    spec:
      volumes:
        - name: mysql-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
      containers:
        - name: mysql-container
          image: mysql:latest
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mysql-storage
              mountPath: /var/lib/mysql
          env:
           - name: MYSQL_ROOT_PASSWORD
             valueFrom:
               secretKeyRef:
                  name: mysql-root-pass
                  key: password
           - name: MYSQL_DATABASE
             valueFrom:
               secretKeyRef:
                  name: mysql-db-url
                  key: database
           - name: MYSQL_USER
             valueFrom:
               secretKeyRef:
                 name: mysql-user-pass
                 key: username
           - name: MYSQL_PASSWORD
             valueFrom:
               secretKeyRef:
                 name: mysql-user-pass
                 key: password

Create the service
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  type: NodePort
  selector:
    db: mysql
  ports:
    - port: 3306
      targetPort: 3306
      nodePort: 30007

-> kubectl create secret generic mysql-root-pass --from-literal=password=YUIidhb667
-> kubectl create secret generic mysql-user-pass --from-literal=username=kodekloud_roy --from-literal=password=YchZHRcLkL
-> kubectl create secret generic mysql-db-url --from-literal=database=kodekloud-db3

-> connect to MySQL container and run the command to switch to the user used
 mysql -u kodekloud_sam -p 
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 9
Server version: 9.6.0 MySQL Community Server - GPL

Copyright (c) 2000, 2026, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| kodekloud_db6      |
| performance_schema |
+--------------------+
3 rows in set (0.005 sec)

This validates the database is created.

Question 3: The Nautilus Application Development team is planning to deploy one of the php-based applications on Kubernetes cluster. As per the recent discussion with DevOps team, they have decided to use nginx and phpfpm. Additionally, they also shared some custom configuration requirements. Below you can find more details. Please complete this task as per requirements mentioned below:

1) Create a service to expose this app, the service type must be NodePort, nodePort should be 30012.
2.) Create a config map named nginx-config for nginx.conf as we want to add some custom settings in nginx.conf.
a) Change the default port 80 to 8097 in nginx.conf.
b) Change the default document root /usr/share/nginx to /var/www/html in nginx.conf.
c) Update the directory index to index  index.html index.htm index.php in nginx.conf.
3.) Create a pod named nginx-phpfpm .
b) Create a shared volume named shared-files that will be used by both containers (nginx and phpfpm) also it should be a emptyDir volume.
c) Map the ConfigMap we declared above as a volume for nginx container. Name the volume as nginx-config-volume, mount path should be /etc/nginx/nginx.conf and subPath should be nginx.conf
d) Nginx container should be named as nginx-container and it should use nginx:latest image. PhpFPM container should be named as php-fpm-container and it should use php:8.1-fpm-alpine image.
e) The shared volume shared-files should be mounted at /var/www/html location in both containers. Copy /opt/index.php from jump host to the nginx document root inside the nginx container, once done you can access the app using App button on the top bar.


Solution:
Config Map
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    user nginx;
    worker_processes auto;

    events {
       worker_connections 512;
    }

    http {
      server {
         listen 8095;
         server_name localhost;

         root /var/www/html;
         index index.html index.htm index.php;

         location / {
           try_files $uri $uri/ =404;
         }

         location ~ \.php$ {
            root /var/www/html;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name;
           }
        }
     }

Pod
apiVersion: v1
kind: Pod
metadata:
  name: nginx-phpfpm
  labels:
    name: nginx-phpfpm-app
spec:
  volumes:
    - name: shared-files
      emptyDir: {}
    - name: nginx-config-volume
      configMap:
        name: nginx-config
  containers:
    - name: nginx-container
      image: nginx:latest
      volumeMounts:
        - name: shared-files
          mountPath: /var/www/html
        - name: nginx-config-volume
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
      ports:
        - containerPort: 8095
    - name: php-fpm-container
      image: php:8.2-fpm-alpine
      volumeMounts:
        - name: shared-files
          mountPath: /var/www/html

Service
apiVersion: v1
kind: Service
metadata:
  name: nginx-phpfpm-app-svc
spec:
  type: NodePort
  selector:
    name: nginx-phpfpm-app
  ports:
    - port: 8095
      targetPort: 8095
      nodePort: 30012

copy the file from local to container
kubectl cp /opt/index.php podname:/var/www/html -c <container name>

Question 4: We need to deploy a Drupal application on Kubernetes cluster. The Nautilus application development team want to setup a fresh Drupal as they will do the installation on their own. Below you can find the requirements, they have shared with us.

1) Configure a persistent volume drupal-mysql-pv with hostPath = /drupal-mysql-data (/drupal-mysql-data directory already exists on the worker Node i.e jump host), 5Gi of storage and ReadWriteOnce access mode.
2) Configure one PersistentVolumeClaim named drupal-mysql-pvc with storage request of 3Gi and ReadWriteOnce access mode.
3) Create a deployment drupal-mysql with 1 replica, use mysql:5.7 image. Mount the claimed PVC at /var/lib/mysql.
4) Create a deployment drupal with 1 replica and use drupal:8.6 image.
4) Create a NodePort type service which should be named as drupal-service and nodePort should be 30095.
5) Create a service drupal-mysql-service to expose mysql deployment on port 3306.
6) Set rest of the configration for deployments, services, secrets etc as per your preferences. At the end you should be able to access the Drupal installation page by clicking on App button.

Solution:
apiVersion: v1
kind: PersistentVolume
metadata:
  name: drupal-mysql-pv
  labels:
    type: local
spec:
  storageClassName: manual
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/drupal-mysql-data"

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: drupal-mysql-pvc
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi


apiVersion: apps/v1
kind: Deployment
metadata:
  name: drupal
  labels:
    app: drupal
spec:
  replicas: 1
  selector:
    matchLabels:
      app: drupal
  template:
    metadata:
      labels:
        app: drupal
    spec:
      containers:
        - name: drupal-app
          image: drupal:8.6
          ports:
            - containerPort: 80
          env:
           - name: MYSQL-ROOT-PASSWORD
             valueFrom:
                secretKeyRef:
                   name: mysql-root-pass
                   key: password
           - name: MYSQL-USER
             valueFrom:
               secretKeyRef:
                  name: mysql-user-pass
                  key: username
           - name: MYSQL-PASSWORD
             valueFrom:
               secretKeyRef:
                  name: mysql-user-pass
                  key: password
           - name: MYSQL-HOST
             valueFrom:
               secretKeyRef:
                 name: mysql-db-url
                 key: database

apiVersion: apps/v1
kind: Deployment
metadata:
  name: drupal-mysql
  lables:
    db: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      db: mysql
  template:
    metadata:
      labels:
        db: mysql
    spec:
      volumes:
        - name: mysql-storage
          persistentVolumeClaim:
            claimName: drupal-mysql-pvc
      containers:
        - name: mysql-containers
          image: mysql:5.7
          volumeMounts:
            - name: mysql-storage
              mountPath: /var/lib/mysql
          ports:
            - containerPort: 3306
          env:
           - name: MYSQL-ROOT-PASSWORD
             valueFrom:
                secretKeyRef:
                  name: mysql-root-pass
                  key: password
           - name: MYSQL-USER
             valueFrom:
                secretKeyRef:
                  name: mysql-user-pass
                  key: username
           - name: MYSQL-PASSWORD
             valueFrom:
               secretKeyRef:
                  name: mysql-user-pass
                  key: password
           - name: MYSQL-HOST
             valueFrom:
                secretKeyRef:
                   name: mysql-db-url
                   key: database

apiVersion: v1
kind: Service
metadata:
  name: drupal-service
spec:
  type: NodePort
  selector:
    app: drupal
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30095

thor@jumphost ~$ cat db-service.yaml 
apiVersion: v1
kind: Service
metadata:
  name: drupal-mysql-service
spec:
  selector:
    db: mysql
  ports:
    - port: 3306
      targetPort: 3306

-> kubectl create secret generic mysql-root-pass --from-literal=password=YUIidhb667
-> kubectl create secret generic mysql-user-pass --from-literal=username=kodekloud_roy --from-literal=password=YchZHRcLkL
-> kubectl create secret generic mysql-db-url --from-literal=database=kodekloud-db3

Question 5: The Nautilus Application development team has finished development of one of the applications and it is ready for deployment. It is a guestbook application that will be used to manage entries for guests/visitors. As per discussion with the DevOps team, they have finalized the infrastructure that will be deployed on Kubernetes cluster. Below you can find more details about it.

BACK-END TIER
Create a deployment named redis-master for Redis master.
a.) Replicas count should be 1.
b.) Container name should be master-redis-devops and it should use image redis.
c.) Request resources as CPU should be 100m and Memory should be 100Mi.
d.) Container port should be redis default port i.e 6379.
Create a service named redis-master for Redis master. Port and targetPort should be Redis default port i.e 6379.
Create another deployment named redis-slave for Redis slave.
a.) Replicas count should be 2.
b.) Container name should be slave-redis-devops and it should use gcr.io/google_samples/gb-redisslave:v3 image.
c.) Requests resources as CPU should be 100m and Memory should be 100Mi.
d.) Define an environment variable named GET_HOSTS_FROM and its value should be dns.
e.) Container port should be Redis default port i.e 6379.
Create another service named redis-slave. It should use Redis default port i.e 6379.

FRONT END TIER
Create a deployment named frontend.
a.) Replicas count should be 3.
b.) Container name should be php-redis-devops and it should use gcr.io/google-samples/gb-frontend@sha256:a908df8486ff66f2c4daa0d3d8a2fa09846a1fc8efd65649c0109695c7c5cbff image.
c.) Request resources as CPU should be 100m and Memory should be 100Mi.
d.) Define an environment variable named as GET_HOSTS_FROM and its value should be dns.
e.) Container port should be 80.
Create a service named frontend. Its type should be NodePort, port should be 80 and its nodePort should be 30009.

Solution:
## Backend Full Deployment File
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-master
  labels:
    db: redis-db
spec:
  replicas: 1
  selector:
    matchLabels:
      db: redis-db
  template:
    metadata:
      labels:
        db: redis-db
    spec:
      containers:
        - name: master-redis-devops
          image: redis
          resources:
            requests:
              cpu: "100m"
              memory: "100Mi"
          ports:
            - containerPort: 6379

---
apiVersion: v1
kind: Service
metadata:
  name: redis-master
spec:
  type: ClusterIP
  selector:
    db: redis-db
  ports:
    - port: 6379
      targetPort: 6379

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-slave
  labels:
    db: redis-db-slave
spec:
  replicas: 2
  selector:
    matchLabels:
      db: redis-db-slave
  template:
    metadata:
      labels:
        db: redis-db-slave
    spec:
      containers:
        - name: slave-redis-devops
          image: gcr.io/google_samples/gb-redisslave:v3
          resources:
            requests:
              cpu: "100m"
              memory: "100Mi"
          ports:
            - containerPort: 6379
          env:
            - name: GET_HOSTS_FROM
              value: dns

---
apiVersion: v1
kind: Service
metadata:
  name: redis-slave
spec:
  type: ClusterIP
  selector:
    db: redis-db-slave
  ports:
    - port: 6379
      targetPort: 6379

## Front End Deployment File
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: php-redis-devops
          image: gcr.io/google-samples/gb-frontend@sha256:a908df8486ff66f2c4daa0d3d8a2fa09846a1fc8efd65649c0109695c7c5cbff
          resources:
            requests:
              cpu: "100m"
              memory: "100Mi"
          env:
            - name: GET_HOSTS_FROM
              value: dns
          ports:
            - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: frontend
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30009

Apply all the configuration and wait for all the pods to be running.

      